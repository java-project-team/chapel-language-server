
PARSER_BEGIN(Parser)

/**
 * Simple brace matcher.
 */
public class Parser {

  /** Main entry point. */
  public static void main(String[] args) throws ParseException {
    Parser parser = new Parser(System.in);
    try {
          SimpleNode n = parser.File();
          n.dump("");
          System.out.println("Thank you.");
        } catch (Exception e) {
          System.out.println("Oops.");
          System.out.println(e.getMessage());
          e.printStackTrace();
        }
  }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}
/* LITERALS */
TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      | <BINARY_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9", "_"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F", "_"])+ >
|
  < #OCTAL_LITERAL: "0" ["O", "o"] (["0"-"7", "_"])+ >
|
  < #BINARY_LITERAL : "0" ["B", "b"] ("0"| "1" |"_")+ >
}
// OPERATORS
TOKEN :
{
  < LCURLYBRACE: "{" >
| < RCURLYBRACE: "}" >
| < LSQUAREBRACKET: "[" >
| < RSQUAREBRACKET: "]" >
| < LPARENTHESIS: "(" >
| < RPARENTHESIS: ")" >
| < COLON: ":" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < QUESTIONMARK: "?" >
| < ASSIGNEQUAL: "=" >
| < MULEQUAL: "*=" >
| < DIVIDEEQUAL: "/=" >
| < MODEQUAL: "%=" >
| < PLUSEQUAL: "+=" >
| < MINUSEQUAL: "-=" >
| < SHIFTLEFTEQUAL: "<<=" >
| < SHIFTRIGHTEQUAL: ">>=" >
| < BITWISEANDEQUAL: "&=" >
| < BITWISEXOREQUAL: "^=" >
| < BITWISEOREQUAL: "|=" >
| < BITWISEXOREQUAL: "^=" >
| < POWEQUAL: "**=">
| < REDUCEEQUAL : "reduce=" >
| < RANGECOUNT : "#" >
| < SWAP : "<=>">
| < IO : "<~>">
| < ARGS : "..." >
| < RANGESPEC : ".." >
| < OR: "||" >
| < AND: "&&" >
| < BITWISEOR: "|" >
| < BITWISEXOR: "^" >
| < BITWISEAND: "&" >
| < EQUAL: "==" >
| < NOTEQUAL: "!=" >
| < LESSTHAN: "<" >
| < GREATERTHAN: ">" >
| < LESSTHANOREQUALTO: "<=" >
| < GREATERTHANOREQUALTO: ">=" >
| < SHIFTLEFT: "<<" >
| < SHIFTRIGHT: ">>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MUL: "*" >
| < DIVIDE: "/" >
| < MOD: "%" >
| < POW: "**">
| < PLUSPLUS: "++" >
| < MINUSMINUS: "--" >
| < TILDE: "~" >
| < NOT: "!" >
| < DOT: "." >
| < POINTERTO: "->" >
| < DOTSTAR: ".*" >
| < ARROWSTAR: "->*" >
// KEYWORDS
| < WILDCARD : "_" >
| < ALIGN : "align" >
| < AS : "as" >
| < ATOMIC : "atomic" >
| < BEGIN : "begin" >
| < BOOL : "bool" >
| < BORROWED : "borrowed" >
| < BREAK : "break" >
| < BY : "by" >
| < BYTES: "bytes" >
| < CATCH : "catch" >
| < CLASS : "class" >
| < COBEGIN : "cobegin" >
| < COFORALL : "coforall" >
| < COMPLEX : "complex" >
| < CONFIG : "config" >
| < CONST : "const" >
| < CONTINUE : "continue" >
| < DEFER: "defer" >
| < DELETE : "delete" >
| < DMAPPED : "dmapped" >
| < DO : "do" >
| < DOMAIN : "domain" >
| < ELSE : "else" >
| < ENUM : "enum" >
| < EXCEPT : "except" >
| < EXPORT : "export" >
| < EXTERN : "extern" >
| < FAlSETOK : "false" >
| < FOR : "for" >
| < FORALL : "forall" >
| < FOREACH: "foreach" >
| < FORWARDING : "forwarding" >
| < IF : "if" >
| < IMAG : "imag" >
| < IMPLEMENTS : "implements" >
| < IN : "in" >
| < INDEX : "index" >
| < INLINE : "inline" >
| < INOUT : "inout" >
| < INT : "int" >
| < INTERFACE : "interface" >
| < ITER : "iter" >
| < LABEL : "label" >
| < LET : "let" >
| < LIFETIME : "lifetime" >
| < LOCAL : "local" >
| < LOCALE : "locale" >
| < MANAGE : "manage" >
| < MODULE : "module" >
| < NEW : "new" >
| < NIL : "nil" >
| <NOINIT : "noinit" >
| < ON : "on" >
| < ONLY : "only" >
| < OPERATOR : "operator" >
| < OTHERWISE : "otherwise" >
| < OUT : "out" >
| < OVERRIDE : "override" >
| < OWNED : "owned" >
| < PARAM : "param" >
| < PRIVATE : "private" >
| < PROTOTYPE : "prototype" >
| < PROC : "proc" >
| < PUBLIC : "public" >
| < REAL : "real" >
| < RECORD : "record" >
| < REDUCE : "reduce" >
| < REF : "ref" >
| < REQUIRE : "require" >
| < RETURN : "return" >
| < SCAN : "scan" >
| < SELECT : "select" >
| < SERIAL : "serial" >
| < SHARED : "shared" >
| < SINGLE : "single" >
| < SPARSE : "sparse" >
| < STRING : "string" >
| < SUBDOMAIN : "subdomain" >
| < SYNC : "sync" >
| < THEN : "then" >
| < THIS : "this" >
| < THROW : "throw" >
| < THROWS: "throws" >
| < TRUE : "true" >
| < TRY : "try" >
| < TYPE : "type" >
| < UNIT : "uint" >
| < UNION : "union" >
| < UNMANAGED : "unmanaged" >
| < USE : "use" >
| < VAR : "var" >
| < WHEN : "when" >
| < WHERE : "where" >
| < WHILE : "while" >
| < WITH : "with" >
| < YIELD : "yield" >
| < ZIP : "zip" >
| < IMPORT : "import" >
}
/* IDENTIFIERS */
TOKEN :
{
  < ID: <LETTER> (<LETTER>|<DIGIT>|"$")* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

/** Root production. */
SimpleNode File() :
{}
{
    Block() <EOF>
    {return jjtThis;}
}

void ArrayLiteral() :
{}
{
    ("[" Expr() ("," Expr())* [","] "]")
    |
    ("[" AssociativeExpr() ("," AssociativeExpr() )* [","] "]")
}

void AssociativeExpr() :
{}
{
    Expr() "=>" Expr()
}

void RangeLiteral() :
{}
{
    [Expr() ] <RANGESPEC> ["<"] [Expr()]
}

void Block() :
{}
{
    (
//    Declaration() | Expr() | Import() |
    Statement())*
}

void Statement() :
{}
{
    BlockStatement()
    | IfStatement()
    | Expr() ";"
    | AssignStatement()
    |  SwapStatement()
    |  IoStatement()
    |  SelectStatement()
    |  WhileDoStatement()
    |  DoWhileStatement()
    |  ForStatement()
    |  LabelStatement()
    |  BreakStatement()
    |  ContinueStatement()
    |  ParamForStatement()
    |  UseStatement()
    |  ImportStatement()
    |  DeferStatement()
    |  EmptyStatement()
    |  ReturnStatement()
    |  YieldStatement()
    |  ModuleDeclarationStatement()
    |  ProcedureDeclarationStatement()
    |  ExternalProcedureDeclarationStatement()
    |  ExportedProcedureDeclarationStatement()
    |  IteratorDeclarationStatement()
    |  MethodDeclarationStatement()
    |  TypeDeclarationStatement()
    |  VariableDeclarationStatement()
    |  RemoteVariableDeclarationStatement()
    |  OnStatement()
    |  CobeginStatement()
    |  CoforallStatement()
    |  BeginStatement()
    |  SyncStatement()
    |  SerialStatement()
    |  ForallStatement()
    |  DeleteStatement()
    |  ManageStatement()
    // IF WHILE FOR FORALL RETURN mb smthing else
}

void SwapStatement() :
{}
{
    LValueExpr() <SWAP> LValueExpr()
}

void IoStatement() :
{}
{
    IOExpr() <IO> Expr() ";"
}

void IOExpr() :
{}
{
    Expr() | IOExpr()  <IO> Expr()
}

void SelectStatement() :
{}
{
    <SELECT> Expr() "{"
    (
    <WHEN> (Expr())+ (<DO> Statement() | BlockStatement())
    | <OTHERWISE> (Statement() | <DO> Statement())
    )
    "}"
}
void CTRLDecl() :
{}
{
     (<VAR> | <CONST>) <ID> <EQUAL> Expr()

}
void WhileDoStatement() :
{}
{
    <WHILE>
    (Expr() | CTRLDecl())  (<DO> Statement() | BlockStatement())
}

void DoWhileStatement() :
{}
{
    <DO> Statement() <WHILE> Expr() ";"
}

void ForStatement() :
{}
{
    <FOR> [(<ID> | "(" <ID> ("," <ID>)* ")" ) <IN>] IterableExpr() (<DO> Statement() | BlockStatement())
}

void IterableExpr() :
{}
{
    Expr() | <ZIP> "(" Expr() ("," Expr())* ")"
}

void LabelStatement() :
{}
{
    <LABEL> <ID> Statement()
}
void BreakStatement() :
{}
{
    <BREAK> [<ID>]
}
void ContinueStatement() :
{}
{
    <CONTINUE> [<ID>]
}
void ParamForStatement() :
{}
{
    <FOR> <PARAM> <ID> <IN> RangeLiteral() [<BY> <INTEGER_LITERAL>] (<DO> Statement() | BlockStatement() )
}
void UseStatement() :
{}
{
    PrivacySpec() <USE> ModuleOrEnumName() ("," ModuleOrEnumName() )* [LimitationClause()]
}

void LimitationClause() :
{}
{
    (<EXCEPT> Exclude() ("," Exclude())* )
    | (<ONLY> [RenameBase() ("," RenameBase())* ])
}

void Exclude() :
{}
{
    Operator()
    | <ID>
}

void ModuleOrEnumName() :
{}
{
    RenameBase()
    | <ID> "." ModuleOrEnumName()
}

void RenameBase() :
{}
{
    (<ID> [<AS> (<ID> | <WILDCARD> ) ])
    | Operator()
}

void ImportStatement() :
{}
{
    [PrivacySpec()] <IMPORT> ImportExpr() ("," ImportExpr() )*
}

void ImportExpr() :
{}
{
    ModuleOrSymbolRename()
    | ModuleOrSymbolBase() UnqualifiedList()
}

void ModuleOrSymbolBase() :
{}
{
    <ID> ["." ModuleOrSymbolBase()]
}

void ModuleOrSymbolRename() :
{}
{
    RenameBase()
    | <ID> "." ModuleOrSymbolRename()
}

void UnqualifiedList() :
{}
{
      "." "{" RenameBase() ("," RenameBase() )* "}"
}

void DeferStatement() :
{}
{
    <DEFER> Statement()
}
void EmptyStatement() :
{}
{
    <SEMICOLON>
}

void ReturnStatement() :
{}
{
    <RETURN> [Expr()] ";"
}

void YieldStatement() :
{}
{
    <YIELD> Expr() ";"
}

void ModuleDeclarationStatement() :
{}
{
    PrivacySpec() <PROTOTYPE> <MODULE> <ID> BlockStatement()
}

void ProcedureDeclarationStatement() :
{}
{
    [PrivacySpec()]
    [ProcKind()]
    (<PROC> <ID> [ArgumentList()] | <OPERATOR> ArgumentList())
    [ReturnIntent()]
    [ReturnType() ]
    [<WHERE> Expr()]
    (BlockStatement() | ReturnStatement() )
}

void ReturnType() :
{}
{
    ":" TypeExpr()
}

void ExternalProcedureDeclarationStatement() :
{}
{
    <EXTERN> [Expr()] <PROC> <ID> ArgumentList() [ReturnIntent()] [ReturnType()]
}

void ExportedProcedureDeclarationStatement() :
{}
{
    <EXPORT> [Expr()] <PROC> <ID> ArgumentList() [ReturnIntent()] [ReturnType() ]
}

void IteratorDeclarationStatement() :
{}
{

}

void MethodDeclarationStatement() :
{}
{

}
void TypeDeclarationStatement() :
{}
{

}
void VariableDeclarationStatement() :
{}
{

}
void RemoteVariableDeclarationStatement() :
{}
{

}
void OnStatement() :
{}
{

}
void CobeginStatement() :
{}
{

}
void CoforallStatement() :
{}
{

}
void BeginStatement() :
{}
{

}
void SyncStatement() :
{}
{

}
void SerialStatement() :
{}
{

}
void ForallStatement() :
{}
{

}
void DeleteStatement() :
{}
{

}
void ManageStatement() :
{}
{
    <MANAGE> ManagerExpr() ManagerExpr() ("," ManagerExpr())* <DO> Statement() | BlockStatement())
}

void ManagerExpr() :
{}
{
    Expr() [<AS> <ID> [VariableKind()] <ID> ]
}

void VariableKind() :
{}
{
    <PARAM>
    | <CONST>
    | <VAR>
    | <REF>
    | <CONST> <REF>
}

void AssignStatement() :
{}
{
    LValueExpr() AssignOperators() Expr() ";"
}

void LValueExpr() :
{}{}

void AssignOperators() :
{}
{
    "="
    | "+="
    | "-="
    | "*="
    | "/="
    | "%="
    | "**="
    | "&="
    | "|="
    | "^="
    | "&&="
    | "||="
    | "<<="
    | ">>="
}

void BlockStatement() :
{}
{
    "{" (Statement())* "}"
}

void IfStatement() :
{}
{
    <IF> (Expr() | CTRLDecl() )
    (<THEN> Statement() | BlockStatement())
    [<ELSE> Statement()]
}

void Import() : {} {}

void Declaration() :
{}
{
    ModuleDeclaration()
    | ProcDeclaration()
    | ClassDeclaration()
}

void PrivacySpec() : {}
{
    <PRIVATE> | <PUBLIC>
}

void ModuleDeclaration() :
{}
{
    [PrivacySpec()] [<PROTOTYPE>] <MODULE> <ID> "{" Block() "}"
}

void Type() :
{}
{
    <INT>
    | <STRING>
    | <COMPLEX>
    | <REAL>
}

void ReturnIntent() :
{}
{
    <CONST> <REF>
    | <CONST>
    | <REF>
    | <PARAM>
    | <TYPE>
}

void TypeExpr() :
{}
{
    //todo
}

void Operator() :
{}
{
//'align' 'by'
//  + - * / % ** : ! == != <= >= < > << >> & | ^ ~
    <ALIGN>
    | <BY>
    |<PLUS>
    | <MINUS>
    | <MUL>
    | <DIVIDE>
    | <MOD>
    | <POW>
    | <COLON>
    | <NOT>
    | <EQUAL>
    | <NOTEQUAL>
    | <LESSTHANOREQUALTO>
    | <GREATERTHANOREQUALTO>
    | <LESSTHAN>
    | <GREATERTHAN>
    | <SHIFTLEFT>
    | <SHIFTRIGHT>
    | <BITWISEAND>
    | <BITWISEOR>
    | <BITWISEXOR>
    | <TILDE>
//  = += -= *= /= %= **= &= |= ^= <<= >>= <=> <~> #
    | <ASSIGNEQUAL>
    | <PLUSEQUAL>
    | <MINUSEQUAL>
    | <MULEQUAL>
    | <DIVIDEEQUAL>
    | <MODEQUAL>
    | <POWEQUAL>
    | <BITWISEANDEQUAL>
    | <BITWISEOREQUAL>
    | <BITWISEXOREQUAL>
    | <SHIFTLEFTEQUAL>
    | <SHIFTRIGHTEQUAL>
    | <SWAP>
    | <IO>
    | <AND>
    | <RANGECOUNT>
    | <MINUSMINUS>
    | <PLUSPLUS>
}

void ArgumentList() :
{}
{
    "(" Formal() ("," Formal()) ")"
}

void TupleGroupedIdentifierList() :
{}
{
    "(" <ID> ("," <ID>)* ")"
}

void FormalType() :
{}
{
    ":" (TypeExpr() | "?" [TypeExpr()])
}

void VariableArgumentExpr() :
{}
{
    <ARGS> (Expr()  | "?" <ID>)?
}

void Formal() :
{}
{
      FormalIntent()
      (<ID> | TupleGroupedIdentifierList())
      [FormalType()]
      ("=" Expr()  | VariableArgumentExpr() )
}

void FormalIntent() :
{}
{
    <CONST> (<IN> | <REF>)?
    | <IN>
    | <OUT>
    | <INOUT>
    | <REF>
    | <PARAM>
    | <TYPE>
}

void ProcKind() :
{}
{
    <INLINE> | <EXPORT> | <EXTERN> | <OVERRIDE>
}

void ClassDeclaration() :
{}
{}

void Expr() :
{}
{

}
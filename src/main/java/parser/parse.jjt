
PARSER_BEGIN(Parser)

/**
 * Simple brace matcher.
 */
public class Parser {

  /** Main entry point. */
  public static void main(String[] args) throws ParseException {
    Parser parser = new Parser(System.in);
    try {
          SimpleNode n = parser.File();
          n.dump("");
          System.out.println("Thank you.");
        } catch (Exception e) {
          System.out.println("Oops.");
          System.out.println(e.getMessage());
          e.printStackTrace();
        }
  }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}
/* LITERALS */
TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
      | <BINARY_LITERAL>
  >
|
  < DECIMAL_LITERAL: ["1"-"9"] (["0"-"9", "_"])* >
|
  < HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F", "_"])+ >
|
  < OCTAL_LITERAL: "0" ["O", "o"] (["0"-"7", "_"])+ >
|
  < BINARY_LITERAL : "0" ["B", "b"] ("0"| "1" |"_")+ >
|
  < EXPONENT_PART: ["e", "E"] ["+", "-"] <INTEGER_LITERAL> >
|
  < PEXPONENT_PART: ["p", "P"] ["+", "-"] <INTEGER_LITERAL> >
|
  <BOOL_LITERAL: (<TRUE> | <FALSE>) >
}

// OPERATORS
TOKEN :
{
  < LCURLYBRACE: "{" >
| < RCURLYBRACE: "}" >
| < LSQUAREBRACKET: "[" >
| < RSQUAREBRACKET: "]" >
| < LPARENTHESIS: "(" >
| < RPARENTHESIS: ")" >
| < COLON: ":" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < QUESTIONMARK: "?" >
| < ASSIGNEQUAL: "=" >
| < MULEQUAL: "*=" >
| < DIVIDEEQUAL: "/=" >
| < MODEQUAL: "%=" >
| < PLUSEQUAL: "+=" >
| < MINUSEQUAL: "-=" >
| < SHIFTLEFTEQUAL: "<<=" >
| < SHIFTRIGHTEQUAL: ">>=" >
| < BITWISEANDEQUAL: "&=" >
| < BITWISEOREQUAL: "|=" >
| < BITWISEXOREQUAL: "^=" >
| < POWEQUAL: "**=">
| < REDUCEEQUAL : "reduce=" >
| < RANGECOUNT : "#" >
| < SWAP : "<=>">
| < IO : "<~>">
| < ARGS : "..." >
| < RANGESPEC : ".." >
| < OR: "||" >
| < AND: "&&" >
| < BITWISEOR: "|" >
| < BITWISEXOR: "^" >
| < BITWISEAND: "&" >
| < EQUAL: "==" >
| < NOTEQUAL: "!=" >
| < LESSTHAN: "<" >
| < GREATERTHAN: ">" >
| < LESSTHANOREQUALTO: "<=" >
| < GREATERTHANOREQUALTO: ">=" >
| < SHIFTLEFT: "<<" >
| < SHIFTRIGHT: ">>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < MUL: "*" >
| < DIVIDE: "/" >
| < MOD: "%" >
| < POW: "**">
| < PLUSPLUS: "++" >
| < MINUSMINUS: "--" >
| < TILDE: "~" >
| < NOT: "!" >
| < DOT: "." >
| < POINTERTO: "->" >
| < DOTSTAR: ".*" >
| < ARROWSTAR: "->*" >
// KEYWORDS
| < VOID: "void" >
| < NOTHING: "nothing" >
| < WILDCARD : "_" >
| < UINT: "uint" >
| < RANGE: "range" >
| < ALIGN : "align" >
| < AS : "as" >
| < ATOMIC : "atomic" >
| < BEGIN : "begin" >
| < BOOL : "bool" >
| < BORROWED : "borrowed" >
| < BREAK : "break" >
| < BY : "by" >
| < BYTES: "bytes" >
| < CATCH : "catch" >
| < CLASS : "class" >
| < COBEGIN : "cobegin" >
| < COFORALL : "coforall" >
| < COMPLEX : "complex" >
| < CONFIG : "config" >
| < CONST : "const" >
| < CONTINUE : "continue" >
| < DEFER: "defer" >
| < DELETE : "delete" >
| < DMAPPED : "dmapped" >
| < DO : "do" >
| < DOMAIN : "domain" >
| < ELSE : "else" >
| < ENUM : "enum" >
| < EXCEPT : "except" >
| < EXPORT : "export" >
| < EXTERN : "extern" >
| < FAlSETOK : "false" >
| < FOR : "for" >
| < FORALL : "forall" >
| < FOREACH: "foreach" >
| < FORWARDING : "forwarding" >
| < IF : "if" >
| < IMAG : "imag" >
| < IMPLEMENTS : "implements" >
| < IN : "in" >
| < INDEX : "index" >
| < INLINE : "inline" >
| < INOUT : "inout" >
| < INT : "int" >
| < INTERFACE : "interface" >
| < ITER : "iter" >
| < LABEL : "label" >
| < LET : "let" >
| < LIFETIME : "lifetime" >
| < LOCAL : "local" >
| < LOCALE : "locale" >
| < MANAGE : "manage" >
| < MODULE : "module" >
| < NEW : "new" >
| < NIL : "nil" >
| <NOINIT : "noinit" >
| < ON : "on" >
| < ONLY : "only" >
| < OPERATOR : "operator" >
| < OTHERWISE : "otherwise" >
| < OUT : "out" >
| < OVERRIDE : "override" >
| < OWNED : "owned" >
| < PARAM : "param" >
| < PRIVATE : "private" >
| < PROTOTYPE : "prototype" >
| < PROC : "proc" >
| < PUBLIC : "public" >
| < REAL : "real" >
| < RECORD : "record" >
| < REDUCE : "reduce" >
| < REF : "ref" >
| < REQUIRE : "require" >
| < RETURN : "return" >
| < SCAN : "scan" >
| < SELECT : "select" >
| < SERIAL : "serial" >
| < SHARED : "shared" >
| < SINGLE : "single" >
| < SPARSE : "sparse" >
| < STRING : "string" >
| < SUBDOMAIN : "subdomain" >
| < SYNC : "sync" >
| < THEN : "then" >
| < THIS : "this" >
| < THROW : "throw" >
| < THROWS: "throws" >
| < TRUE : "True" >
| < FALSE : "False" >
| < TRY : "try" >
| < TYPE : "type" >
| < UNION : "union" >
| < UNMANAGED : "unmanaged" >
| < USE : "use" >
| < VAR : "var" >
| < WHEN : "when" >
| < WHERE : "where" >
| < WHILE : "while" >
| < WITH : "with" >
| < YIELD : "yield" >
| < ZIP : "zip" >
| < MINMAX : "minmax">
| < MINLOC : "minloc">
| < MAXLOC : "maxloc">
| < MIN : "min">
| < MAX : "max">
| < IMPORT : "import" >
}
/* IDENTIFIERS */
TOKEN :
{
  < ID: <LETTER> (<LETTER>|<DIGIT>|"$")* >
|
  < #LETTER: ["_","a"-"z","A"-"Z"] >
|
  < #DIGIT: ["0"-"9"] >
}

/** Root production. */
SimpleNode File() :
{}
{
    Block() <EOF>
    {return jjtThis;}
}

void ArrayLiteral() :
{}
{
    LOOKAHEAD(3)("[" Expression() ("," Expression())* "]")
    |
    LOOKAHEAD(3)("[" AssociativeExpr() ("," AssociativeExpr() )* "]")
}

void AssociativeExpr() :
{}
{
    Expression() "=>" Expression()
}

void RangeLiteral() :
{}
{
    [Expression() ] <RANGESPEC> ["<"] [LOOKAHEAD(2)Expression()]
}

void Block() :
{}
{
    (
    Statement())*
}

void  ExpressionStatement() :
{}
{
LetExpression() ";"
|NewExpression() ";"
|LvalueExpression() ";"
|CallExpression() ";"
|MemberAccessExpression() ";"
|Identifier() ";"
}

void Statement() :
{}
{
    BlockStatement()
    | IfStatement()
    | ExpressionStatement()
    | AssignStatement()
    |  SwapStatement()
    |  IoStatement()
    |  SelectStatement()
    |  WhileDoStatement()
    |  DoWhileStatement()
    |  ForStatement()
    |  LabelStatement()
    |  BreakStatement()
    |  ContinueStatement()
    |  ParamForStatement()
    |  UseStatement()
    |  ImportStatement()
    |  DeferStatement()
    |  EmptyStatement()
    |  ReturnStatement()
    |  YieldStatement()
    |  ModuleDeclarationStatement()
    |  ProcedureDeclarationStatement()
    |  ExternalProcedureDeclarationStatement()
    |  ExportedProcedureDeclarationStatement()
    |  IteratorDeclarationStatement()
    |  MethodDeclarationStatement()
    |  TypeDeclarationStatement()
    |  VariableDeclarationStatement()
    |  RemoteVariableDeclarationStatement()
    |  OnStatement()
    |  CobeginStatement()
    |  CoforallStatement()
    |  BeginStatement()
    |  SyncStatement()
    |  SerialStatement()
    |  ForallStatement()
    |  DeleteStatement()
    |  ManageStatement()
}

void SwapStatement() :
{}
{
    LvalueExpression() <SWAP> LvalueExpression()
}

void IoStatement() :
{}
{
    IOExpr() <IO> Expression() ";"
}

void IOExpr() :
{}
{
    Expression() //| IOExpr()  <IO> Expression()
}

void SelectStatement() :
{}
{
    <SELECT> Expression() "{"
    (
    <WHEN> (Expression())+ (<DO> Statement() | BlockStatement())
    | <OTHERWISE> (Statement() | <DO> Statement())
    )
    "}"
}
void CTRLDecl() :
{}
{
     (<VAR> | <CONST>) <ID> <EQUAL> Expression()

}
void WhileDoStatement() :
{}
{
    <WHILE>
    (Expression() | CTRLDecl())  (<DO> Statement() | BlockStatement())
}

void DoWhileStatement() :
{}
{
    <DO> Statement() <WHILE> Expression() ";"
}

void ForStatement() :
{}
{
    <FOR> [(<ID> | "(" <ID> ("," <ID>)* ")" ) <IN>] IterableExpr() (<DO> Statement() | BlockStatement())
}

void IterableExpr() :
{}
{
    Expression() | <ZIP> "(" Expression() ("," Expression())* ")"
}

void LabelStatement() :
{}
{
    <LABEL> <ID> Statement()
}
void BreakStatement() :
{}
{
    <BREAK> [<ID>]
}
void ContinueStatement() :
{}
{
    <CONTINUE> [<ID>]
}
void ParamForStatement() :
{}
{
    <FOR> <PARAM> <ID> <IN> RangeLiteral() [<BY> <INTEGER_LITERAL>] (<DO> Statement() | BlockStatement() )
}
void UseStatement() :
{}
{
    PrivacySpecifier() <USE> ModuleOrEnumName() ("," ModuleOrEnumName() )* [LimitationClause()]
}

void LimitationClause() :
{}
{
    (<EXCEPT> Exclude() ("," Exclude())* )
    | (<ONLY> [RenameBase() ("," RenameBase())* ])
}

void Exclude() :
{}
{
    Operator()
    | <ID>
}

void ModuleOrEnumName() :
{}
{
    RenameBase()
    | <ID> "." ModuleOrEnumName()
}

void RenameBase() :
{}
{
    (<ID> [<AS> (<ID> | <WILDCARD> ) ])
    | Operator()
}

void ImportStatement() :
{}
{
    [PrivacySpecifier()] <IMPORT> ImportExpr() ("," ImportExpr() )*
}

void ImportExpr() :
{}
{
    ModuleOrSymbolRename()
    | ModuleOrSymbolBase() UnqualifiedList()
}

void ModuleOrSymbolBase() :
{}
{
    <ID> ["." ModuleOrSymbolBase()]
}

void ModuleOrSymbolRename() :
{}
{
    RenameBase()
    | <ID> "." ModuleOrSymbolRename()
}

void UnqualifiedList() :
{}
{
      "." "{" RenameBase() ("," RenameBase() )* "}"
}

void DeferStatement() :
{}
{
    <DEFER> Statement()
}
void EmptyStatement() :
{}
{
    <SEMICOLON>
}

void ReturnStatement() :
{}
{
    <RETURN> [Expression()] ";"
}

void YieldStatement() :
{}
{
    <YIELD> Expression() ";"
}

void ModuleDeclarationStatement() :
{}
{
    PrivacySpecifier() <PROTOTYPE> <MODULE> <ID> BlockStatement()
}

void ProcedureDeclarationStatement() :
{}
{
    [PrivacySpecifier()]
    [ProcKind()]
    (<PROC> <ID> [ArgumentList()] | <OPERATOR> ArgumentList())
    [ReturnIntent()]
    [ReturnType() ]
    [WhereClause() ]

}

void FunctionBody():
{}
{
    BlockStatement() | ReturnStatement()
}

void WhereClause() : {}
{
    <WHERE> Expression()
}
void ReturnType() :
{}
{
    ":" TypeExpression()
}

void ExternalProcedureDeclarationStatement() :
{}
{
    <EXTERN> [Expression()] <PROC> <ID> ArgumentList() [ReturnIntent()] [ReturnType()]
}

void ExportedProcedureDeclarationStatement() :
{}
{
    <EXPORT> [Expression()] <PROC> <ID> ArgumentList() [ReturnIntent()] [ReturnType() ]
}

void IteratorDeclarationStatement() :
{}
{
    [PrivacySpecifier() ] <ITER> <ID> [ArgumentList()] [YieldIntent() ] [YieldType() ] [WhereClause() ]
    (YieldStatement() | BlockStatement())
}

void YieldType() :
{}
{
    ":" TypeExpression()
}

void YieldIntent() :
{}
{
    <CONST> (<REF>)?
    | <REF>
    | <PARAM>
    | <TYPE>
}
void MethodDeclarationStatement() :
{}
{
    [ProcKind()] (<PROC> | <ITER>) [ThisIntent()]  [TypeBinding()]
        <ID> [ArgumentList() ] [ReturnIntent()] [ReturnType()] [WhereClause()]  FunctionBody()
}

void TypeBinding() : {}
{
    <ID> "."
    | "(" Expression() ")" "."
}

void ThisIntent() :
{}
{
    <PARAM>
    |<TYPE>
    |<REF>
    |<CONST> (<REF>)?
}

void TypeDeclarationStatement() :
{}
{
    EnumDeclarationStatement()
    |  ClassDeclarationStatement()
    |  RecordDeclarationStatement()
    |  UnionDeclarationStatement()
    |  TypeAliasDeclarationStatement()
}

void EnumDeclarationStatement() :
{}
{
  <ENUM> <ID> "{" EnumConstantList() "}"
}

void EnumConstantList() :
{}
{
  EnumConstant()
|  EnumConstant() "," [EnumConstantList()]
}

void EnumConstant():
{}
{
    <ID> [InitPart()]
}

void InitPart(): {}
{
    "=" Expression()
}

void ClassDeclarationStatement(): {}
{
    <CLASS> <ID> [ClassInherit()] "{"[ ClassStatementList()]"}"
}

void ClassInherit() :
{}
{
    ":" BasicClassType()
}

void BasicClassType() :
{}
{
    <ID> "(" NamedExpressionList() ")"
    |<ID>
}

void  NamedExpressionList() :
{}
{
    NamedExpression() "," NamedExpressionList()
    |NamedExpression()
}

void  NamedExpression() :
{}
{
    Expression()
    |<ID> "=" Expression()
}

void ClassStatementList() :
{}
{
    ClassStatement() ClassStatementList()
    |ClassStatement()
}

void ClassStatement() :
{}
{
    VariableDeclarationStatement()
    |MethodDeclarationStatement()
    |TypeDeclarationStatement()
    |EmptyStatement()
}

void RecordDeclarationStatement() :
{}
{
    SimpleRecordDeclarationStatement()
    | ExternalRecordDeclarationStatement()
}

void ExternalRecordDeclarationStatement() :
{}
{
    <EXTERN> [Expression()] SimpleRecordDeclarationStatement()
}

void Identifier() :{} {<ID>}

void SimpleRecordDeclarationStatement() :
{}
{
    <RECORD> Identifier() "{" RecordStatementList() "}"
}

void RecordStatementList() :
{}
{
    RecordStatement()
    |RecordStatement() RecordStatementList()
}

void RecordStatement() :
{}
{
    VariableDeclarationStatement()
    |MethodDeclarationStatement()
    |TypeDeclarationStatement()
    |EmptyStatement()
}

void UnionDeclarationStatement() :
{}
{
    [<EXTERN> ] <UNION> Identifier() "{" UnionStatementList()"}"
}

void UnionStatementList() :
{}
{
    UnionStatement() UnionStatementList()
    |UnionStatement()
}

void UnionStatement() :
{}
{
    TypeDeclarationStatement()
    |ProcedureDeclarationStatement()
    |IteratorDeclarationStatement()
    |VariableDeclarationStatement()
    |EmptyStatement()
}

void TypeAliasDeclarationStatement() :
{}
{
    [PrivacySpecifier()] [<CONFIG>] <TYPE> TypeAliasDeclarationList() ";"
    | ExternalTypeAliasDeclarationStatement()
}

void  ExternalTypeAliasDeclarationStatement() :
{}
{
    <EXTERN> [Expression()] <TYPE> TypeAliasDeclarationList()
}

void TypeAliasDeclarationList() :
{}
{
    TypeAliasDeclaration() "," TypeAliasDeclarationList()
    |TypeAliasDeclaration()
}

void TypeAliasDeclaration() :
{}
{
    Identifier()
    |Identifier() "=" TypeExpression()
}

void VariableDeclarationStatement() :
{}
{
    [PrivacySpecifier()] [ConfigExternOrExport()] VariableKind() VariableDeclarationList() ";"
}

void ConfigExternOrExport():
{}
{
    <CONFIG>
    |<EXTERN>
    |<EXPORT>
}

void VariableKind() :
{}
{
<PARAM>
|<CONST> [<REF>]
|<VAR>
|<REF>
}

void VariableDeclarationList() :
{}
{
    VariableDeclaration() "," VariableDeclarationList()
    |VariableDeclaration()
}

void VariableDeclaration() :
{}
{
    IdentifierList() [TypePart()] [InitializationPart()]
}

void TypePart() :
{}
{
 ":" TypeExpression()
}

void InitializationPart() :
{}
{
 "=" Expression()
}

void IdentifierList() :
{}
{
    Identifier() "," IdentifierList()
    |Identifier()
    |TupleGroupedIdentifierList() "," IdentifierList()
    |TupleGroupedIdentifierList()
}

void TupleGroupedIdentifierList() :
{}
{
    "(" IdentifierList() ")"
}

void RemoteVariableDeclarationStatement() :
{}
{
    <ON> Expression() VariableDeclarationStatement()
}

void OnStatement() :
{}
{
    <ON> Expression() <DO> Statement()
    |<ON> Expression() BlockStatement()
}

void CobeginStatement() :
{}
{
    <COBEGIN> [TaskIntentClause()] BlockStatement()
}


void  TaskIntentClause() :
{}
{
    <WITH> "(" TaskIntentList() ")"
}

void  TaskIntentItem() :
{}
{
FormalIntent() Identifier()
|ReduceScanOperator() <REDUCE> Identifier()
|ClassType() <REDUCE> Identifier()
|TaskPrivateVarDecl()
}

void ClassType() :
{}
{
    BasicClassType()
    |<OWNED> BasicClassType()
    |<SHARED> BasicClassType()
    |<BORROWED> BasicClassType()
    |<UNMANAGED> BasicClassType()
}

void  ReduceScanOperator() :
{}
{
"+"
|"*"
|"&&"
|"||"
|"&"
|"|"
|"^"
|<MINMAX>
|<MINLOC>
|<MAXLOC>
|<MIN>
|<MAX>
}

void  TaskIntentList() :
{}
{
    TaskIntentItem() "," TaskIntentList()
    |TaskIntentItem()
}

void  TaskPrivateVarDecl() :
{}
{
    TaskPrivateVarKind() Identifier() [TypePart()] [InitializationPart()]
}

void  TaskPrivateVarKind() :
{}
{
<CONST>
|<VAR>
|<REF>
}

void CoforallStatement() :
{}
{
 <COFORALL> IndexVarDeclaration() <IN> IteratableExpression()[TaskIntentClause()] <DO> Statement()
|<COFORALL> IndexVarDeclaration() <IN> IteratableExpression()[TaskIntentClause()] BlockStatement()
|<COFORALL> IteratableExpression() [TaskIntentClause()] <DO> Statement()
|<COFORALL> IteratableExpression() [TaskIntentClause()] BlockStatement()
}

void  IteratableExpression() :
{}
{
    Expression()
    |<ZIP> "(" ExpressionList() ")"
}

void ExpressionList() :
{}
{
    Expression() "," ExpressionList()
    |Expression()
}

void  IndexVarDeclaration() :
{}
{
Identifier()
|TupleGroupedIdentifierList()
}

void  BeginStatement() :
{}
{
    <BEGIN> [TaskIntentClause()] Statement()
}

void  SyncStatement() :
{}
{
 <SYNC> Statement()
|<SYNC> BlockStatement()
}

void  SyncType() :
{}
{
 <SYNC> TypeExpression()
}

void  SerialStatement() :
{}
{
 <SERIAL> [Expression()] <DO> Statement()
|<SERIAL> [Expression()] BlockStatement()
}

void  AtomicType() :
{}
{
    <ATOMIC> TypeExpression()
}

void  SingleType() :
{}
{
    <SINGLE> TypeExpression()
}

void  ForallStatement() :
{}
{
  <FORALL> IndexVarDeclaration() <IN> IteratableExpression() [TaskIntentClause()] <DO> Statement()
| <FORALL> IndexVarDeclaration() <IN> IteratableExpression() [TaskIntentClause()] BlockStatement()
| <FORALL> IteratableExpression() [TaskIntentClause()] <DO> Statement()
| <FORALL> IteratableExpression() [TaskIntentClause()] BlockStatement()
| "[" IndexVarDeclaration() <IN> IteratableExpression() [TaskIntentClause()] "]" Statement()
| "[" IteratableExpression() [TaskIntentClause()] "]" Statement()
}

void  DeleteStatement() :
{}
{
 <DELETE> ExpressionList() ";"
}

void ManageStatement() :
{}
{
    <MANAGE> ManagerExpressionList() <DO> Statement()
    |<MANAGE> ManagerExpressionList() BlockStatement()
}

void ManagerExpression() :
{}
{
Expression() <AS> VariableKind() Identifier()
|Expression() <AS> Identifier()
|Expression()
}

void ManagerExpressionList() :
{}
{
    ManagerExpression()
//    | ManagerExpressionList() ","  ManagerExpression()
}

void AssignStatement() :
{}
{
    LvalueExpression() AssignOperators() Expression() ";"
}

void  LvalueExpression() :
{}
{
    Identifier()
    |MemberAccessExpression()
    |ParenthesizedExpression()
//    | CallExpression()
}

void  ParenthesizedExpression() :
{}
{
    "(" Expression() ")"
}

void  CallExpression() :
{}
{
 LvalueExpression()"[" NamedExpressionList()"]"
|LvalueExpression()"(" NamedExpressionList()")"
}

void  MemberAccessExpression() :
{}
{
    MethodCallExpression()
    | FieldAccessExpression()
}

void  MethodCallExpression() :
{}
{
ReceiverClause() Expression()"(" NamedExpressionList() ")"
|ReceiverClause() Expression()"[" NamedExpressionList() "]"
|ReceiverClause() Identifier()
}

void  ReceiverClause() :
{}
{
    Expression() "."
}

void  FieldAccessExpression() :
{}
{
    ReceiverClause() Identifier()
}


void AssignOperators() :
{}
{
    "="
    | "+="
    | "-="
    | "*="
    | "/="
    | "%="
    | "**="
    | "&="
    | "|="
    | "^="
    | "&&="
    | "||="
    | "<<="
    | ">>="
}

void BlockStatement() :
{}
{
    "{" (Statement())* "}"
}

void IfStatement() :
{}
{
    <IF> (Expression() | CTRLDecl() )
    (<THEN> Statement() | BlockStatement())
    [<ELSE> Statement()]
}

//void Declaration() :
//{}
//{
//    ModuleDeclaration()
//    | ProcDeclaration()
//    | ClassDeclaration()
//}

void PrivacySpecifier() : {}
{
    <PRIVATE> | <PUBLIC>
}

void ReturnIntent() :
{}
{
    <CONST> <REF>
    | <CONST>
    | <REF>
    | <PARAM>
    | <TYPE>
}

void  TypeExpression() :
{}
{
 PrimitiveType()
|Identifier()
|StructuredType()
|DataparallelType()
|SynchronizationType()
|LvalueExpression()
|IfExpression()
|UnaryExpression()
|BinaryExpression()
}

void  SynchronizationType() :
{}
{
 SyncType()
|SingleType()
|AtomicType()
}

void  DataparallelType() :
{}
{
 RangeType()
|DomainType()
|MappedDomainType()
|ArrayType()
|IndexType()
}

void  MappedDomainType() :
{}
{
 DomainType() <DMAPPED> DmapValue()
}

void  ArrayType() :
{}
{
 "[" DomainExpression() "]" TypeExpression()
}

void  IndexType() :
{}
{
 <INDEX> "(" DomainExpression() ")"
}

void  RangeType() :
{}
{
 <RANGE> "(" NamedExpressionList() ")"
}

void  StructuredType() :
{}
{
 ClassType()
| RecordType()
| Identifier()
| TupleType()
}

void  RecordType() :
{}
{
 Identifier()
|Identifier()"(" NamedExpressionList() ")"
}

void  TupleType() :
{}
{
 "(" TypeExpression() "," TypeList() ")"
|"(" TypeExpression()"," ")"
}

void  TypeList() :
{}
{
 TypeExpression()
|TypeExpression()"," TypeList()
}

void  PrimitiveTypeParameterPart() :
{}
{
 "(" IntegerParameterExpression() ")"
}

void  IntegerParameterExpression() :
{}
{
 Expression()
}

void  PrimitiveType() :
{}
{
 <VOID> 
|<NOTHING>
|<BOOL> [PrimitiveTypeParameterPart()]
|<INT> [PrimitiveTypeParameterPart()]
|<UINT> [PrimitiveTypeParameterPart()]
|<REAL> [PrimitiveTypeParameterPart()]
|<IMAG> [PrimitiveTypeParameterPart()]
|<COMPLEX> [PrimitiveTypeParameterPart()]
|<STRING>
|<BYTES>
|<ENUM>
|<RECORD>
|<CLASS>
|<OWNED>
|<SHARED>
|<UNMANAGED>
|<BORROWED>
}

void Operator() :
{}
{
//'align' 'by'
//  + - * / % ** : ! == != <= >= < > << >> & | ^ ~
    <ALIGN>
    | <BY>
    |<PLUS>
    | <MINUS>
    | <MUL>
    | <DIVIDE>
    | <MOD>
    | <POW>
    | <COLON>
    | <NOT>
    | <EQUAL>
    | <NOTEQUAL>
    | <LESSTHANOREQUALTO>
    | <GREATERTHANOREQUALTO>
    | <LESSTHAN>
    | <GREATERTHAN>
    | <SHIFTLEFT>
    | <SHIFTRIGHT>
    | <BITWISEAND>
    | <BITWISEOR>
    | <BITWISEXOR>
    | <TILDE>
//  = += -= *= /= %= **= &= |= ^= <<= >>= <=> <~> #
    | <ASSIGNEQUAL>
    | <PLUSEQUAL>
    | <MINUSEQUAL>
    | <MULEQUAL>
    | <DIVIDEEQUAL>
    | <MODEQUAL>
    | <POWEQUAL>
    | <BITWISEANDEQUAL>
    | <BITWISEOREQUAL>
    | <BITWISEXOREQUAL>
    | <SHIFTLEFTEQUAL>
    | <SHIFTRIGHTEQUAL>
    | <SWAP>
    | <IO>
    | <AND>
    | <RANGECOUNT>
    | <MINUSMINUS>
    | <PLUSPLUS>
}

void ArgumentList() :
{}
{
    "(" Formal() ("," Formal())* ")"
}

void FormalType() :
{}
{
    ":" (TypeExpression() | "?" [TypeExpression()])
}

void VariableArgumentExpr() :
{}
{
    <ARGS> (Expression()  | "?" <ID>)?
}

void Formal() :
{}
{
      FormalIntent()
      (<ID> | TupleGroupedIdentifierList())
      [FormalType()]
      ("=" Expression()  | VariableArgumentExpr() )
}

void FormalIntent() :
{}
{
    <CONST> (<IN> | <REF>)?
    | <IN>
    | <OUT>
    | <INOUT>
    | <REF>
    | <PARAM>
    | <TYPE>
}

void ProcKind() :
{}
{
    <INLINE> | <EXPORT> | <EXTERN> | <OVERRIDE>
}

void Expression() :
{}
{
Identifier()
|EnumConstantExpression()
//|CallExpression()
//|TypeExpression()
//|IteratableCallExpression()
|NewExpression()
|QueryExpression()
//|LvalueExpression()
//|CastExpression()
//|LiteralExpression()
//|MemberAccessExpression()
|ParenthesizedExpression()
|UnaryExpression()
//|BinaryExpression()
|LetExpression()
|IfExpression()
|ForExpression()
|ForallExpression()
|ReduceExpression()
|ScanExpression()
|ModuleAccessExpression()
|TupleExpression()
|TupleExpandExpression()
//|LocaleQueryExpression()
//|TypeQueryExpression()
|MappedDomainExpression()
}

void  TypeQueryExpression() :
{}
{
    Expression()"." <TYPE>
}

void  MappedDomainExpression() :
{}
{
    DomainExpression() <DMAPPED> DmapValue()
}

void  DmapValue() :
{}
{
 Expression()
}

void  DomainExpression() :
{}
{
(DomainLiteral()
|Identifier()
|DomainAssignmentExpression()) (DomainAlignmentExpression() | DomainStridingExpression() | DomainSliceExpression())
}

void  DomainAlignmentExpression() :
{}
{
 <ALIGN> Expression() DomainAlignmentExpression()
}

void  DomainAssignmentExpression() :
{}
{
 Identifier() "=" DomainExpression()
}

void  DomainSliceExpression() :
{}
{
 ("[" SlicingIndexSet() "]" | "(" SlicingIndexSet() ")") DomainSliceExpression()
}

void  SlicingIndexSet() :
{}
{
 DomainExpression()
|RangeExpressionList()
}

void  DomainStridingExpression() :
{}
{
 <BY> Expression() DomainStridingExpression()
}

void  DomainType() :
{}
{
 BaseDomainType()
|SimpleSubdomainType()
|SparseSubdomainType()
}

void  SimpleSubdomainType() :
{}
{
 <SUBDOMAIN> "(" DomainExpression() ")"
}

void  SparseSubdomainType() :
{}
{
 <SPARSE>[<SUBDOMAIN>]"(" DomainExpression() ")"
}

void  BaseDomainType() :
{}
{
 RectangularDomainType()
|AssociativeDomainType()
}

void  RectangularDomainType() :
{}
{
 <DOMAIN>"(" NamedExpressionList() ")"
}

void  AssociativeDomainType() :
{}
{
 <DOMAIN> "(" AssociativeIndexType() ")"
}

void  AssociativeIndexType() :
{}
{
 TypeExpression()
}

void  LocaleQueryExpression() :
{}
{
    Expression()"." <LOCALE>
}

void  TupleExpandExpression() :
{}
{
    "(" <ARGS> Expression() ")"
}

void  TupleExpression() :
{}
{
 "(" TupleComponent() "," ")"
| "(" TupleComponent() "," TupleComponentList() ")"
| "(" TupleComponent() "," TupleComponentList() "," ")"
}

void  TupleComponentList() :
{}
{
 TupleComponent()
|TupleComponent() "," TupleComponentList()
}

void  TupleComponent() :
{}
{
 Expression()
| "_"
}

void  ModuleAccessExpression() :
{}
{
    ModuleIdentifierList() "." Identifier()
}

void  ModuleIdentifierList() :
{}
{
Identifier()
|Identifier() "." ModuleIdentifierList()
}

void  ReduceExpression() :
{}
{
    ReduceScanOperator()<REDUCE> IteratableExpression()
    |ClassType()<REDUCE> IteratableExpression()
}

void  ScanExpression() :
{}
{
    ReduceScanOperator() <SCAN> IteratableExpression()
    |ClassType() <SCAN> IteratableExpression()
}

void  IfExpression() :
{}
{
<IF> Expression() <THEN> Expression() <ELSE> Expression()
| <IF> Expression() <THEN> Expression()
}

void  ForExpression() :
{}
{
<FOR> IndexVarDeclaration() <IN> IteratableExpression() <DO> Expression()
|<FOR> IteratableExpression() <DO> Expression()
}

void  ForallExpression() :
{}
{
 <FORALL> IndexVarDeclaration() <IN> IteratableExpression() [TaskIntentClause()] <DO> Expression()
| <FORALL> IteratableExpression() [TaskIntentClause()] <DO> Expression()
|"[" IndexVarDeclaration() <IN> IteratableExpression() [TaskIntentClause()] "]" Expression()
|"[" IteratableExpression() [TaskIntentClause()] "]" Expression()
}

void  LetExpression() :
{}
{
    <LET> VariableDeclarationList() <IN> Expression()
}

void  BinaryExpression() :
{}
{
    Expression() BinaryOperator() Expression()
}

void  BinaryOperator() :
{}
{
 "+" | "-" | "*" | "/" | "%" | <POW> | "&" | "|" | "^"
 | <SHIFTLEFT> | <SHIFTRIGHT> | <AND> | <OR> | <EQUAL>
 | <NOTEQUAL> | <LESSTHANOREQUALTO> | <GREATERTHANOREQUALTO>
 | <LESSTHAN> | <GREATERTHAN> | <BY> | <RANGECOUNT>
}

void  UnaryExpression() :
{}
{
    UnaryOperator() Expression()
}

void  UnaryOperator() :
{}
{
 "+" | "-" | "~" | "!"
}

void  CastExpression() :
{}
{
   Expression() ":" TypeExpression()
}

void QueryExpression() :
{}
{
    "?" [Identifier()]
}

void  NewExpression() :
{}
{
  <NEW> TypeExpression()"(" ArgumentList() ")"
}

void  IteratableCallExpression() :
{}
{
    CallExpression()
}

void  EnumConstantExpression() :
{}
{
    Identifier() "." Identifier()
}

void  LiteralExpression() :
{}
{
 BoolLiteral()
|IntegerLiteral()
|RealLiteral()
|ImaginaryLiteral()
|StringLiteral()
|BytesLiteral()
|RangeLiteral()
|DomainLiteral()
|ArrayLiteral()
}
void RealLiteral() : {} {<REAL_LITERAL> }
void ImaginaryLiteral() : {} {<IMAGINARY_LITERAL> }
void StringLiteral() : {} {
<INTERPRETED_STRING_LITERAL>
}

void  BoolLiteral() :
{}
{
  <BOOL_LITERAL>
}

void  IntegerLiteral() :
{}
{
    <INTEGER_LITERAL>
}

TOKEN : {
  <REAL_LITERAL :
    ((<INTEGER_LITERAL>)? "."  (<EXPONENT_PART>)?)
    | <INTEGER_LITERAL> (".")? <EXPONENT_PART>
    | (<HEX_LITERAL> )? "." <HEX_LITERAL> (<PEXPONENT_PART>)?
    | (<HEX_LITERAL> )? "." <HEX_LITERAL>  (<PEXPONENT_PART>)?
    |  <HEX_LITERAL> (".")? <PEXPONENT_PART>
    |  <HEX_LITERAL> (".")? <PEXPONENT_PART>
    >
| <IMAGINARY_LITERAL :
       <INTEGER_LITERAL> "i"
       | <REAL_LITERAL> "I">
}
void  RectangularDomainLiteral() :
{}
{
 "{" RangeExpressionList() "}"
}

void  RangeExpressionList() :
{}
{
    RangeExpression()
    |RangeExpression() "," RangeExpressionList()
}

void  RangeExpression() :
{}
{
    Expression()
//    |StridedRangeExpression()
//    |CountedRangeExpression()
//    |AlignedRangeExpression()
//    |SlicedRangeExpression()
}

void  SlicedRangeExpression() :
{}
{
    RangeExpression() "(" RangeExpression() ")"
    |RangeExpression() "[" RangeExpression() "]"
}

void AlignedRangeExpression() :
{}
{
    RangeExpression() <ALIGN> Expression()
}

void  CountedRangeExpression() :
{}
{
    RangeExpression() "#" Expression()
}

void  StridedRangeExpression() :
{}
{
    RangeExpression() <BY> StepExpression()
}

void  StepExpression() :
{}
{
  Expression()
}

void  DomainLiteral() :
{}
{
    RectangularDomainLiteral()
    |AssociativeDomainLiteral()
}

void  AssociativeDomainLiteral() :
{}
{
 "{" AssociativeExpressionList() "}"
}

void  AssociativeExpressionList() :
{}
{
    NonRangeExpression()
    |NonRangeExpression() "," AssociativeExpressionList()
}

void  NonRangeExpression() :
{}
{
 Expression()
}

TOKEN : {
<BYTES_LITERAL : "B" ("\"" (<DOUBLE_QUOTE_DELIMITED_CHARACTERS>)? | "'" (<SINGLE_QUOTE_DELIMITED_CHARACTERS>)?)>
| <UNINTERPRETED_STRING_LITERAL:
      "\"\"\"" ((~["\""] | "\"" "\"" ~["\""]))* "\"\"\""
      | "\'\'\'" (~["\'"])* "\'\'\'"
      >
| <INTERPRETED_STRING_LITERAL:
    "\"" (<DOUBLE_QUOTE_DELIMITED_CHARACTERS>)? "\""
    | "\'" (<SINGLE_QUOTE_DELIMITED_CHARACTERS>)? "\'"
    >
| <#DOUBLE_QUOTE_DELIMITED_CHARACTERS:
    (~["\"", "\n"])+
    >
| <SINGLE_QUOTE_DELIMITED_CHARACTERS:
    (~["\'", "\n"])+
    >
}

void  BytesLiteral() :
{}
{
    <BYTES_LITERAL>
}

void  Digits() :
{}
{
  <INTEGER_LITERAL>
}

